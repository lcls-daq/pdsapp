/*
 * This is an XTC merge utility that attempts to merge two XTC files into one.  We are assuming that
 * these are generated by camrecord, and so the format is a bit simplified.  (We configure and run
 * once and only once, etc.)
 */
#include<stdio.h>
#include<getopt.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<fcntl.h>
#include"pdsdata/xtc/Xtc.hh"
#include"pdsdata/xtc/TimeStamp.hh"
#include"pdsdata/xtc/Dgram.hh"
#include"pdsdata/xtc/XtcIterator.hh"
#include"pdsdata/xtc/XtcFileIterator.hh"

using namespace std;
using namespace Pds;

// Fiducial math!
#define FID_MAX        0x1ffe0
#define FID_ROLL_LO    0x00200
#define FID_ROLL_HI    (FID_MAX-FID_ROLL_LO)
#define FID_ROLL(a,b)  ((b) < FID_ROLL_LO && (a) > FID_ROLL_HI)
#define FID_GT(a,b)    (FID_ROLL(b, a) || ((a) > (b) && !FID_ROLL(a, b)))
#define FID_DIFF(a,b)  ((FID_ROLL(b, a) ? FID_MAX : 0) + (a) - (b) - (FID_ROLL(a, b) ? FID_MAX : 0))

#define CHUNK_SIZE 107374182400LL

char *fname[3]           = {NULL, NULL, NULL};
int   chunk[3]           = {0,    0,    0};
int   fd[3]              = {-1,   -1,   -1};
long long off[3]         = {0,    0,    0};
XtcFileIterator *iter[2] = {NULL, NULL};
Dgram *dg[2]             = {NULL, NULL};
char   transition_xtc[sizeof(Xtc)];
int verbose = 0;
int next_dg(int n);

void usage(void)
{
    printf("xtcmerge -o OUTPUT XTC1 XTC2\n\n");
    printf("Note that the merged file will only contain the transitions from the\n");
    printf("*FIRST* file, but will contain the data from both.\n");
    exit(1);
}

int chunk_open(char *name, int &chunk, int flags)
{
    char buf[1024];
    sprintf(buf, "%s-c%02d.xtc", name, chunk++);
    return open(buf, flags, 0644);
}

// 0 == failure!
int open_in(int n)
{
    if (fd[n] >= 0) {
        close(fd[n]);
        delete iter[n];
    }
    fd[n] = chunk_open(fname[n], chunk[n], O_RDONLY | O_LARGEFILE);
    if (fd[n] < 0)
        return 0;
    iter[n] = new XtcFileIterator(fd[n], 0x40000000);
    return next_dg(n);
}

// 0 == Failure
int open_out(void)
{
    if (fd[2] >= 0)
        close(fd[2]);
    fd[2] = chunk_open(fname[2], chunk[2], O_WRONLY | O_CREAT | O_LARGEFILE);
    return (fd[2] >= 0);
}

// 0 == failure!
int next_dg(int n)
{
    off[n] = lseek64(fd[n], 0, SEEK_CUR);
    if ((dg[n] = iter[n]->next()) == NULL) {
        if (verbose)
            printf("EOF on fd[%d]\n", n);
        if (!open_in(n)) {
            if (verbose)
                printf("No more chunks for %d!\n", n);
            return 0;
        }
    }
    if (verbose)
        printf("IN%d %s transition: clock 0x%x/0x%x, time 0x%x/0x%x, payloadSize %d\n", n,
               TransitionId::name(dg[n]->seq.service()),
               dg[n]->seq.clock().seconds(), dg[n]->seq.clock().nanoseconds(),
               dg[n]->seq.stamp().fiducials(),dg[n]->seq.stamp().ticks(),
               dg[n]->xtc.sizeofPayload());
    return 1;
}

int do_write(int fd, char *buf, int size)
{
    int left, cur;
    for (left = size, cur = 0; left;) {
        int n = write(fd, &buf[cur], left);
        if (n < 0)
            return size - left;
        left -= n;
        cur += n;
    }
    return size;
}

/*
 * Combine dg[0] and dg[1] and write it into fd[2].
 *
 * So what do we have here?
 *           |---------- Dgram -------------|
 *    dg0 -> Seq0, Env0, Xtc0 (segment level), payload0
 *    dg1 -> Seq1, Env1, Xtc1 (segment level), payload1
 * What we want to write:
 *    Seq0, Env0, XtcN(payloadsize = Xtc0.payloadsize + Xtc1.payloadsize),
 *                payload0, payload1
 * This assumes that the Seq and Env are "close enough".
 */
void output(void)
{
    char buf[sizeof(Dgram)];
    Dgram *dgnew = (Dgram *)buf;
    memcpy(buf, dg[0], sizeof(Dgram));
    dgnew->xtc.extent += dg[1]->xtc.sizeofPayload();
    if (off[2] + dgnew->xtc.extent >= CHUNK_SIZE) {
        if (!open_out()) {
            printf("Cannot create new chunk for output!\n");
            exit(1);
        }
        off[2] = 0;
    }
    off[2] += dgnew->xtc.extent + sizeof(Dgram) - sizeof(Xtc);
    do_write(fd[2], buf, sizeof(buf));
    do_write(fd[2], dg[0]->xtc.payload(), dg[0]->xtc.sizeofPayload());
    do_write(fd[2], dg[1]->xtc.payload(), dg[1]->xtc.sizeofPayload());
}

/*
 * Combine dg[0] and transition_xtc and write it into fd[2].
 *
 * So what do we have here?
 *           |---------- Dgram -------------|
 *    dg0 -> Seq0, Env0, Xtc0 (segment level), payload0
 *    transition_xtc is the payload of any transition in the second file.
 * What we want to write:
 *    Seq0, Env0, XtcN(payloadsize = Xtc0.payloadsize + sizeof(transition_xtc)
 *                payload0, transition_xtc
 */
void output_transition(void)
{
    char buf[sizeof(Dgram)];
    Dgram *dgnew = (Dgram *)buf;
    memcpy(buf, dg[0], sizeof(Dgram));
    dgnew->xtc.extent += sizeof(transition_xtc);
    if (off[2] + dgnew->xtc.extent >= CHUNK_SIZE) {
        if (!open_out()) {
            printf("Cannot create new chunk for output!\n");
            exit(1);
        }
        off[2] = 0;
    }
    off[2] += dgnew->xtc.extent + sizeof(Dgram) - sizeof(Xtc);
    do_write(fd[2], buf, sizeof(buf));
    do_write(fd[2], dg[0]->xtc.payload(), dg[0]->xtc.sizeofPayload());
    do_write(fd[2], transition_xtc, sizeof(transition_xtc));
}

void get_transition_xtc()
{
    while (dg[1]->seq.service() != TransitionId::BeginRun) {
        if (!next_dg(1)) {
            printf("EOF while scanning for BeginRun transition?!?\n");
            exit(0);
        }
    }
    memcpy(transition_xtc, dg[1]->xtc.payload(), dg[1]->xtc.sizeofPayload());
    chunk[1] = 0; /* Reopen the input file! */
    open_in(1);
}

int main(int argc, char **argv)
{
    int c;
    static struct option long_options[] = {
        {"help",      0, 0, 'h'},
        {"output",    1, 0, 'o'},
        {"verbose",   0, 0, 'v'},
        {NULL, 0, NULL, 0}
    };
    int fid0, fid1;
    int idx = 0;
    int done = 0;

    while ((c = getopt_long(argc, argv, "ho:v", long_options, &idx)) != -1) {
        switch (c) {
        case 'h':
            usage();
            break;
        case 'o':
            fname[2] = optarg;
            break;
        case 'v':
            verbose = 1;
            break;
        }
    }
    if (optind + 2 > argc) {
        printf("Not enough arguments!\n");
        exit(1);
    }
    if (!fname[2]) {
        printf("No output file!\n");
        exit(1);
    }
    fname[0] = argv[optind];
    fname[1] = argv[optind + 1];
    printf("Merging %s and %s into %s\n", fname[0], fname[1], fname[2]);

    if (!open_in(0)) {
        printf("Cannot open %s!\n", fname[0]);
        exit(1);
    }
    if (!open_in(1)) {
        printf("Cannot open %s!\n", fname[1]);
        exit(1);
    }
    if (!open_out()) {
        printf("Cannot create %s!\n", fname[2]);
        exit(1);
    }
    get_transition_xtc();

    while (!done) {
        // We have two datagrams.  Check for a match!
        switch (dg[0]->seq.service()) {
        case TransitionId::Configure:
            if (dg[1]->seq.service() != TransitionId::Configure) {
                printf("No Configure transition in second input file?!?\n");
                exit(0);
            }
            output();
            if (!next_dg(0) || !next_dg(1))
                done = 1;
            break;
        case TransitionId::L1Accept:
            if (dg[1]->seq.service() != TransitionId::L1Accept) {
                /* We don't care about transitions in the second file! */
                if (!next_dg(1))
                    done = 1;
                break;
            }
            /*
             * If the time doesn't match, advance one stream.  But the times
             * may differ slightly in the low bits... so instead, we make sure
             * that the seconds are close, and if so, compare the fiducials.
             *
             * (We should be off by a fraction of a second, at most.  But since
             * this could take us to the next second, a difference of 1 might be
             * normal.)
             */
            if (abs(dg[0]->seq.clock().seconds() - dg[1]->seq.clock().seconds()) > 2) {
                if (dg[0]->seq.clock().seconds() > dg[1]->seq.clock().seconds()) {
                    if (!next_dg(1))
                        done = 1;
                } else {
                    if (!next_dg(0))
                        done = 1;
                }
                break;
            } else if ((fid0 = dg[0]->seq.stamp().fiducials()) != 
                       (fid1 = dg[1]->seq.stamp().fiducials())) {
                if (FID_GT(fid0, fid1)) {
                    if (!next_dg(1))
                        done = 1;
                } else {
                    if (!next_dg(0))
                        done = 1;
                }
                break;
            }
            output();
            if (!next_dg(0) || !next_dg(1))
                done = 1;
            break;
        default:
            output_transition();
            if (!next_dg(0))
                done = 1;
            break;
        }
    }
    /* If we still have transitions in the first file, output all of them! */
    while (dg[0] != NULL) {
        if (dg[0]->seq.service() != TransitionId::L1Accept)
            output_transition();
        next_dg(0);
    }
}
