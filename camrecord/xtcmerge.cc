/*
 * This is an XTC merge utility that attempts to merge two XTC files into one.  We are assuming that
 * these are generated by camrecord, and so the format is a bit simplified.  (We configure and run
 * once and only once, etc.)
 */
#include<stdio.h>
#include<getopt.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<fcntl.h>
#include"pdsdata/xtc/Xtc.hh"
#include"pdsdata/xtc/TimeStamp.hh"
#include"pdsdata/xtc/Dgram.hh"
#include"pdsdata/xtc/XtcIterator.hh"
#include"pdsdata/xtc/XtcFileIterator.hh"

using namespace std;
using namespace Pds;

// Fiducial math!
#define FID_MAX        0x1ffe0
#define FID_ROLL_LO    0x00200
#define FID_ROLL_HI    (FID_MAX-FID_ROLL_LO)
#define FID_ROLL(a,b)  ((b) < FID_ROLL_LO && (a) > FID_ROLL_HI)
#define FID_GT(a,b)    (FID_ROLL(b, a) || ((a) > (b) && !FID_ROLL(a, b)))
#define FID_DIFF(a,b)  ((FID_ROLL(b, a) ? FID_MAX : 0) + (a) - (b) - (FID_ROLL(a, b) ? FID_MAX : 0))

#define CHUNK_SIZE 107374182400LL

char *fname[3]           = {NULL, NULL, NULL};
int   chunk[3]           = {0,    0,    0};
int   fd[3]              = {-1,   -1,   -1};
long long off[3]         = {0,    0,    0};
XtcFileIterator *iter[2] = {NULL, NULL};
Dgram *dg[2]             = {NULL, NULL};
int verbose = 0;
int next_dg(int n);

void usage(void)
{
    printf("xtcmerge -o OUTPUT XTC1 XTC2\n");
    exit(1);
}

int chunk_open(char *name, int &chunk, int flags)
{
    char buf[1024];
    sprintf(buf, "%s-c%02d.xtc", name, chunk++);
    return open(buf, flags, 0644);
}

// 0 == failure!
int open_in(int n)
{
    if (fd[n] >= 0) {
        close(fd[n]);
        delete iter[n];
    }
    fd[n] = chunk_open(fname[n], chunk[n], O_RDONLY | O_LARGEFILE);
    if (fd[n] < 0)
        return 0;
    iter[n] = new XtcFileIterator(fd[n], 0x40000000);
    return next_dg(n);
}

// 0 == Failure
int open_out(void)
{
    if (fd[2] >= 0)
        close(fd[2]);
    fd[2] = chunk_open(fname[2], chunk[2], O_WRONLY | O_CREAT | O_LARGEFILE);
    return (fd[2] >= 0);
}

// 0 == failure!
int next_dg(int n)
{
    off[n] = lseek64(fd[n], 0, SEEK_CUR);
    if ((dg[n] = iter[n]->next()) == NULL) {
        if (verbose)
            printf("EOF on fd[%d]\n", n);
        if (!open_in(n)) {
            if (verbose)
                printf("No more chunks for %d!\n", n);
            return 0;
        }
    }
    if (verbose)
        printf("IN%d %s transition: clock 0x%x/0x%x, time 0x%x/0x%x, payloadSize %d\n", n,
               TransitionId::name(dg[n]->seq.service()),
               dg[n]->seq.clock().seconds(), dg[n]->seq.clock().nanoseconds(),
               dg[n]->seq.stamp().fiducials(),dg[n]->seq.stamp().ticks(),
               dg[n]->xtc.sizeofPayload());
    return 1;
}

int do_write(int fd, char *buf, int size)
{
    int left, cur;
    for (left = size, cur = 0; left;) {
        int n = write(fd, &buf[cur], left);
        if (n < 0)
            return size - left;
        left -= n;
        cur += n;
    }
    return size;
}

/*
 * Combine dg[0] and dg[1] and write it into fd[2].
 *
 * So what do we have here?
 *    dg0 -> Seq0, Env0, Xtc0 (segment), Xtc0a (source), payload0a
 *    dg1 -> Seq1, Env1, Xtc1 (segment), Xtc1a (source), payload1a
 * What we want to write:
 *    Seq0, Env0, XtcN(payload = Xtc0.payload + Xtc1.payload),
 *                Xtc0a(payload = Xtc, payload0a, ... payload0b, ...
 * This assumes that the Seq and Env are "close enough".
 */
void output(void)
{
    char buf[sizeof(Dgram)];
    Dgram *dgnew = (Dgram *)buf;
    memcpy(buf, dg[0], sizeof(Dgram));
    dgnew->xtc.extent += dg[1]->xtc.sizeofPayload();
    if (off[2] + dgnew->xtc.extent >= CHUNK_SIZE) {
        if (!open_out()) {
            printf("Cannot create new chunk for output!\n");
            exit(1);
        }
        off[2] = 0;
    }
    off[2] += dgnew->xtc.extent + sizeof(Dgram) - sizeof(Xtc);
    do_write(fd[2], buf, sizeof(buf));
    do_write(fd[2], dg[0]->xtc.payload(), dg[0]->xtc.sizeofPayload());
    do_write(fd[2], dg[1]->xtc.payload(), dg[1]->xtc.sizeofPayload());
}

int main(int argc, char **argv)
{
    int c;
    static struct option long_options[] = {
        {"help",      0, 0, 'h'},
        {"output",    1, 0, 'o'},
        {"verbose",   0, 0, 'v'},
        {NULL, 0, NULL, 0}
    };
    int fid0, fid1;
    int idx = 0;

    while ((c = getopt_long(argc, argv, "ho:v", long_options, &idx)) != -1) {
        switch (c) {
        case 'h':
            usage();
            break;
        case 'o':
            fname[2] = optarg;
            break;
        case 'v':
            verbose = 1;
            break;
        }
    }
    if (optind + 2 > argc) {
        printf("Not enough arguments!\n");
        exit(1);
    }
    if (!fname[2]) {
        printf("No output file!\n");
        exit(1);
    }
    fname[0] = argv[optind];
    fname[1] = argv[optind + 1];
    printf("Merging %s and %s into %s\n", fname[0], fname[1], fname[2]);

    if (!open_in(0)) {
        printf("Cannot open %s!\n", fname[0]);
        exit(1);
    }
    if (!open_in(1)) {
        printf("Cannot open %s!\n", fname[1]);
        exit(1);
    }
    if (!open_out()) {
        printf("Cannot create %s!\n", fname[2]);
        exit(1);
    }

    for (;;) {
        // We have two datagrams.  Check for a match!
        if (dg[0]->seq.service() != dg[1]->seq.service()) {
            /*
             * Different types.  This should only happen when one 
             * runs out of L1Accepts before the other.
             */
            if (dg[0]->seq.service() != TransitionId::L1Accept &&
                dg[0]->seq.service() != TransitionId::L1Accept) {
                printf("IN1 %s transition does not match IN2 %s transition!\n",
                       TransitionId::name(dg[0]->seq.service()),
                       TransitionId::name(dg[1]->seq.service()));
                exit(1);
            }
            if (dg[0]->seq.service() == TransitionId::L1Accept) {
                if (!next_dg(0))
                    break;
            } else {
                if (!next_dg(1))
                    break;
            }
            continue;
        }
        if (dg[0]->seq.service() == TransitionId::L1Accept &&
            (fid0 = dg[0]->seq.stamp().fiducials()) != 
            (fid1 = dg[1]->seq.stamp().fiducials())) {
            if (FID_GT(fid0, fid1)) {
                if (!next_dg(1))
                    break;
            } else {
                if (!next_dg(0))
                    break;
            }
            continue;
        }
        // Match!
        output();
        if (!next_dg(0) || !next_dg(1))
            break;
        continue;
    }
}
