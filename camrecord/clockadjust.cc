/*
 * This is an XTC merge utility that attempts to merge two XTC files into one.  We are assuming that
 * these are generated by camrecord, and so the format is a bit simplified.  (We configure and run
 * once and only once, etc.)
 */
#include<stdio.h>
#include<getopt.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<fcntl.h>
#include<new>
#include"pdsdata/xtc/Xtc.hh"
#include"pdsdata/xtc/TimeStamp.hh"
#include"pdsdata/xtc/Dgram.hh"
#include"pdsdata/xtc/XtcIterator.hh"
#include"pdsdata/xtc/XtcFileIterator.hh"

using namespace std;
using namespace Pds;

char *in_fname = NULL;
char *out_fname = NULL;
int   chunk              = 0;
int   in_fd              = -1;
int   out_fd             = -1;
XtcFileIterator *iter    = NULL;
Dgram *dg                = NULL;
int verbose = 0;
int secs = 0;

int next_dg();

void usage(void)
{
    printf("clockadjust -t SECS -o OUTPUT INPUT\n");
    exit(1);
}

int chunk_open(char *name, int chunk, int flags)
{
    char buf[1024];
    sprintf(buf, "%s-c%02d.xtc", name, chunk);
    return open(buf, flags, 0644);
}

// 0 == failure!
int open_in()
{
    if (in_fd >= 0) {
        close(in_fd);
        delete iter;
    }
    in_fd = chunk_open(in_fname, chunk, O_RDONLY | O_LARGEFILE);
    if (in_fd < 0)
        return 0;
    iter = new XtcFileIterator(in_fd, 0x40000000);
    return next_dg();
}

// 0 == Failure
int open_out(void)
{
    if (out_fd >= 0)
        close(out_fd);
    out_fd = chunk_open(out_fname, chunk, O_WRONLY | O_CREAT | O_LARGEFILE);
    return (out_fd >= 0);
}

// 0 == failure!
int next_dg()
{
    if ((dg = iter->next()) == NULL) {
        if (verbose)
            printf("EOF on input\n");
        if (!open_in()) {
            if (verbose)
                printf("No more chunks for input!\n");
            return 0;
        }
        if (!open_out()) {
            printf("Cannot open output for chunk %d!\n", chunk);
            return 0;
        }
        chunk++;
    }
    if (verbose)
        printf("IN %s transition: clock 0x%x/0x%x, time 0x%x/0x%x, payloadSize %d\n",
               TransitionId::name(dg->seq.service()),
               dg->seq.clock().seconds(), dg->seq.clock().nanoseconds(),
               dg->seq.stamp().fiducials(),dg->seq.stamp().ticks(),
               dg->xtc.sizeofPayload());
    return 1;
}

int do_write(int fd, char *buf, int size)
{
    int left, cur;
    for (left = size, cur = 0; left;) {
        int n = write(fd, &buf[cur], left);
        if (n < 0)
            return size - left;
        left -= n;
        cur += n;
    }
    return size;
}

/*
 * Add offset into dg and write it into out_fd.
 */
void output(void)
{
    Sequence::Type ty = dg->seq.type();
    TransitionId::Value v = dg->seq.service();
    ClockTime cold = dg->seq.clock();
    ClockTime cnew = ClockTime(cold.seconds() + secs, cold.nanoseconds());
    TimeStamp ts = dg->seq.stamp();
    new ((void *) &dg->seq) Sequence(ty, v, cnew, ts);
    do_write(out_fd, (char *)dg, sizeof(Dgram));
    do_write(out_fd, dg->xtc.payload(), dg->xtc.sizeofPayload());
}

int main(int argc, char **argv)
{
    int c;
    static struct option long_options[] = {
        {"help",      0, 0, 'h'},
        {"output",    1, 0, 'o'},
        {"time",      1, 0, 't'},
        {"verbose",   0, 0, 'v'},
        {NULL, 0, NULL, 0}
    };
    int idx = 0;
    
    while ((c = getopt_long(argc, argv, "ho:t:v", long_options, &idx)) != -1) {
        switch (c) {
        case 'h':
            usage();
            break;
        case 'o':
            out_fname = optarg;
            break;
        case 't':
            secs = atoi(optarg);
            break;
        case 'v':
            verbose = 1;
            break;
        }
    }
    if (optind + 1 > argc) {
        printf("Not enough arguments!\n");
        exit(1);
    }
    if (!out_fname) {
        printf("No output file!\n");
        exit(1);
    }
    in_fname = argv[optind];
    printf("Adding time offset %d to %s, producing %s.\n", secs, in_fname, out_fname);

    if (!open_in()) {
        printf("Cannot open %s!\n", in_fname);
        exit(1);
    }
    if (!open_out()) {
        printf("Cannot create %s!\n", out_fname);
        exit(1);
    }
    chunk++;

    for (;;) {
        output();
        if (!next_dg())
            break;
    }
}
