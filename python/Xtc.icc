//
//  pds_Xtc class methods
//
static void      pdsxtc_dealloc(pdsxtc* self);
static PyObject* pdsxtc_new    (PyTypeObject* type, PyObject* args, PyObject* kwds);
static int       pdsxtc_init   (pdsxtc*       self, PyObject* args, PyObject* kwds);
static int       pdsxtc_read   (PyObject*     self, 
				const Pds::Src& info, 
				const Pds::TypeId& contains, 
				const char* fname);

static PyMemberDef pdsxtc_members[] = {
  {NULL} 
};

static PyMethodDef pds_Xtc_methods[] = {
  {NULL},
};

DefineXtcType(Xtc)

#include "pdsdata/xtc/DetInfo.hh"

//
//  pdsxtc class functions
//

void pdsxtc_dealloc(pdsxtc* self)
{
  if (self->extent) {
    self->extent = 0;
    delete[] self->payload;
  }

  self->ob_type->tp_free((PyObject*)self);
}

PyObject* pdsxtc_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
  pdsxtc* self;

  self = (pdsxtc*)type->tp_alloc(type,0);
  if (self != NULL) {
    self->src      = Pds::Src();
    self->contains = Pds::TypeId(Pds::TypeId::Any,0);
    self->extent   = 0;
  }

  return (PyObject*)self;
}

int pdsxtc_init(pdsxtc* self, PyObject* args, PyObject* kwds)
{
  int sts;

  { char* kwlist[] = {"level","phy","contains",NULL};
    unsigned level, phy, contains;
    sts = PyArg_ParseTupleAndKeywords(args,kwds,"III",kwlist,
                                      &level,&phy,&contains);
    if (sts) {
      switch(level) {
      case Pds::Level::Source:
	{ Pds::DetInfo::Detector det   = Pds::DetInfo::Detector( (phy>>24)&0xff );
	  unsigned               detid( (phy>>16)&0xff );
	  Pds::DetInfo::Device   dev   = Pds::DetInfo::Device( (phy>> 8)&0xff );
	  unsigned               devid( (phy>> 0)&0xff );
          self->src = Pds::DetInfo(0,det,detid,dev,devid);
	  break; }
      default:
	{ self->src = Pds::Src(Pds::Level::Type(level)); 
	  break; }
      }
      self->contains = Pds::TypeId(Pds::TypeId::Type(contains&0xffff),contains>>16);
      self->extent   = 0;
      return 0;
    }
  }
  return -1;
}

int       pdsxtc_read  (PyObject*     self, 
			const Pds::Src& info, 
			const Pds::TypeId& contains, 
			const char* fname)
{
  pdsxtc* xtc = (pdsxtc*)self;
  xtc->src      = info;
  xtc->contains = contains;
  xtc->extent   = 0;

  struct stat file_stat;
  if (stat(fname,&file_stat)) return -1;
  char* buff = new char[file_stat.st_size];
  FILE* input = fopen(fname,"r");
  fread(buff, file_stat.st_size, 1, input);
  fclose(input);

  xtc->extent  = file_stat.st_size;
  xtc->payload = buff;

  return 0;
}
